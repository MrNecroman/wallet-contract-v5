#include "imports/stdlib.fc";

int bls_pairing_check(slice x1, slice y1, slice x2, slice y2, slice x_3, slice y_3, slice x_4, slice y_4, int n) asm "BLS_PAIRING";
slice bls_g1_negate(slice x) asm "BLS_G1_NEG";
slice bls_g1_mul(slice x, int s) asm "BLS_G1_MUL";
slice bls_g1_add(slice x, slice y) asm "BLS_G1_ADD";


;; these ops need otp code verify
const op::refresh_otp = "op::refresh_otp"c;
const op::cancel_otp = "op::cancel_otp"c;
const op::send_msg = "op::send_msg"c;


;; these ops don't needs otp code verify
const op::activate_emergency = "op::activate_emergency"c; ;; done


;; only internal messages
const op::disable_emergency = "op::disable_emergency"c; ;; done
const op::change_public_key = "op::change_public_key"c; ;; done
const op::set_code = "op::set_code"c; ;; done


const mode::emeregency = 1; ;; in this mode the wallet private key is probably compromised and every message should be checked by OTP code in recv_internal
const mode::not_init = 2; ;; in this mode we need to send the wallet to turn off sign mode(during deploy tx)



;; storage variables
global int ctx_mode;
global int ctx_root;
global int ctx_nonce;
global int ctx_last_time;
global int ctx_expiration_time;
global int ctx_failed_attempts;
global int ctx_public_key;
global slice ctx_wallet_address;

;; load_data populates storage variables using stored data
() load_data() impure {
    var ds = get_data().begin_parse();
    ctx_mode = ds~load_uint(2);
    ctx_root = ds~load_uint(256);
    ctx_nonce = ds~load_uint(32);
    ctx_last_time = ds~load_uint(64);
    ctx_failed_attempts = ds~load_uint(4);
    ctx_expiration_time = ds~load_uint(32);
    ctx_public_key = ds~load_uint(256);
    ctx_wallet_address = ds~load_msg_addr();

    ds.end_parse();
}

;; save_data stores storage variables as a cell into persistent storage
() save_data() impure {
    set_data(
        begin_cell()
            .store_uint(ctx_mode, 2) ;;
            .store_uint(ctx_root, 256)
            .store_uint(ctx_nonce, 32)
            .store_uint(ctx_last_time, 64)
            .store_uint(ctx_failed_attempts, 4)
            .store_uint(ctx_expiration_time, 32)
            .store_uint(ctx_public_key, 256)
            .store_slice(ctx_wallet_address)
            .end_cell()
    );
}

(int) check_otp_proof(int time, int root, int actions_hash, slice otp_proof) impure inline {
    try {

        slice IC0 = "acc23092c55cb665c59f7dc4cc80da95553f4e0f6b3b9ecda3bcc43a4773d151f208d2702c801d7012cf5343664816b8"s;
        slice IC1 = "89f4af820c466eb1bae168f7198d453b2f185ae2e751b0377d96eb4c5535f9c50c9aec6194e7198ff4113b90022d1026"s;
        slice IC2 = "b827213a0eb36dbac28a6eff07a11f9bd28bd148880b6cf01acde5a5ce0751a6c15be7396a2cdeb870174bb347d35407"s;
        slice IC3 = "b053e86d8ca6fb71957e18a1cf50af7c212457ed34871a83fa6009bec012e93a8aefb4619c153138ffcb760d3f40802a"s;

        slice gamma2 = "93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"s;
        slice delta2 = "b28ab227231face1d9089b55d484f0b818aa343d2a88bb5983b2e9bc0ee90e4a17229610514ab0610e0a9feeb73097f0184a556f045869c7c8cd5c7919a184ddb83a2c78143e3f5999f1ff6b90ef4e6f2e0690e2ddaba7c26a88ac646a9289ef"s;
        slice alf1 = "86eb9de1fae7b540e09c26303cee8b99784835d37bf46f3fb1db25b7b063d9ab9aa866e79f7cc4eb209224c8465b9bde"s;
        slice beta2 = "9091cd3cdc8abaa367a61d5e094dc91ceec4a831f9c995e0b6d38cff4a9cf897a6bb7cc6d1fbb54068bbd8bb479e56d5010417ac1b215ac661897a156c587791a9cc20dffd3d60009696a749136c6b874f8f7a6c2e951843ef410ee953d0354c"s;

        cell A_cell = otp_proof~load_ref();
        cell B_cell = otp_proof~load_ref();
        cell C_cell = otp_proof~load_ref();
        slice A = A_cell.begin_parse();
        slice B = B_cell.begin_parse();
        slice C = C_cell.begin_parse();
        slice vk_x = IC0;

        vk_x = bls_g1_add(vk_x, bls_g1_mul(IC1, time));
        vk_x = bls_g1_add(vk_x, bls_g1_mul(IC2, root));
        vk_x = bls_g1_add(vk_x, bls_g1_mul(IC3, actions_hash));

        slice neg_a = bls_g1_negate(A);

        return bls_pairing_check(neg_a,
            B,
            alf1,
            beta2,
            vk_x,
            gamma2,
            C,
            delta2,
            4);
    } catch (_, _){
        return 0;
    }

}

(int) valid_time(int time) impure inline {
    ;; return
    if (time <= ctx_last_time) {
        return false;
    }
    return (time < (now() * 1000 + 60000)) & (time > (now() * 1000 - 60000));
}
;; recv_internal is the main function of the contract and is called when it receives a message from other contracts
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }


    load_data();

    if (ctx_mode == mode::not_init) {
        send_raw_message(
            begin_cell()
                .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
                .store_slice(ctx_wallet_address)
                .store_coins(20000000)
                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(
                    in_msg_body~load_ref()
                )
                .end_cell(),
            0
        );
        ctx_mode = 0;
        save_data();
        return ();
    }
    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case


    ;; todo should add transfer notifcation here to extend the expiration time:)
    var signature = in_msg_body~load_bits(512);
    slice signed_payload = in_msg_body;
    var op_signed = in_msg_body~load_uint(32);
    throw_unless(38, op_signed == op);
    throw_unless(35, check_signature(slice_hash(signed_payload), signature, ctx_public_key));

    int time = in_msg_body~load_uint(64); ;; in milliseconds

    throw_unless(33, valid_time(time));
    slice otp_proof = in_msg_body~load_ref().begin_parse();
    cell remaining_payload = in_msg_body~load_ref();
    int given_actions_hash = in_msg_body~load_uint(256);
    int actions_hash = remaining_payload.begin_parse().slice_hash();
    throw_unless(42, given_actions_hash == actions_hash);

    int check_otp = check_otp_proof(time, ctx_root, actions_hash, otp_proof);
    throw_unless(34, check_otp);
    ctx_failed_attempts = 0;
    ctx_last_time = time;
    if (op == op::disable_emergency) {
        ctx_mode = 0;
        save_data();
        return ();
    }

    if (op == op::change_public_key) {
        slice remaining_payload_slice = remaining_payload.begin_parse();
        ctx_public_key = remaining_payload_slice~load_uint(256);
        save_data();
        return ();
    }

    if (op == op::refresh_otp) {
        slice remaining_payload_slice = remaining_payload.begin_parse();

        ctx_root = remaining_payload_slice~load_uint(256);
        save_data();
        return ();
    }


    if (op == op::cancel_otp) {
        ;; cancel otp and remove from extension list
        send_raw_message(
            begin_cell()
                .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
                .store_slice(ctx_wallet_address)
                .store_coins(20000000)
                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(
                    remaining_payload
                )
                .end_cell(),
            0
        );
        ;; todo send remaining balance to the ctx_wallet_address and only keep a small amount
        save_data();
        return ();
    }

    if (op == op::send_msg) {
        slice remaining_payload_slice = remaining_payload.begin_parse();

        var coins = remaining_payload_slice~load_coins();
        send_raw_message(
            begin_cell()
                .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
                .store_slice(ctx_wallet_address)
                .store_coins(coins)
                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(
                    remaining_payload_slice~load_ref()
                )
                .end_cell(),
            0
        );
        save_data();
        return ();
    }
    if (op == op::set_code) {
        cell new_code = remaining_payload;
        set_c3(new_code.begin_parse().bless());
        load_data();
        set_code(new_code);

        save_data();
        return ();
    }
    ;; todo should add other ops also


    throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
}

;; get methods are a means to conveniently read contract data using, for example, HTTP APIs
;; they are marked with method_id
;; note that unlike in many other smart contract VMs, get methods cannot be called by other contracts


() recv_external(slice in_msg) impure {
    var signature = in_msg~load_bits(512);
    var cs = in_msg;
    var (op, valid_until, msg_seqno) = (cs~load_uint(32), cs~load_uint(32), cs~load_uint(32));
    throw_if(32, valid_until <= now());

    load_data();
    throw_unless(35, check_signature(slice_hash(in_msg), signature, ctx_public_key));
    throw_unless(33, msg_seqno == ctx_nonce);
    if (mode::emeregency == ctx_mode) {
        throw(36);
    }

    if ((op == op::activate_emergency) | (ctx_failed_attempts >= 3)) {
        accept_message();
        ctx_mode = mode::emeregency;
        ctx_nonce += 1;
        save_data();
        return ();
    }

    int time = cs~load_uint(64); ;; in milliseconds
    throw_unless(41, valid_time(time));
    slice proof_data = cs~load_ref().begin_parse();
    cell remaining_payload = cs~load_ref();
    int given_actions_hash = cs~load_uint(256);
    int actions_hash = remaining_payload.begin_parse().slice_hash();
    throw_unless(42, given_actions_hash == actions_hash);
    accept_message();


    int check_otp = check_otp_proof(time, ctx_root, actions_hash, proof_data);

    if (check_otp == 0) {
        ;; otp proof is invalid
        ctx_failed_attempts += 1;
        ctx_nonce += 1;
        save_data();
        return ();
    }
    ctx_last_time = time;
    ctx_failed_attempts = 0;
    ctx_nonce += 1;

    if (op == op::send_msg) {
        slice remaining_payload_slice = remaining_payload.begin_parse();
        var coins = remaining_payload_slice~load_coins();
        send_raw_message(
            begin_cell()
                .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
                .store_slice(ctx_wallet_address)
                .store_coins(coins)
                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(
                    remaining_payload_slice~load_ref()
                )
                .end_cell(),
            0
        );
        save_data();
        return ();
    } elseif (op == op::refresh_otp) {
        slice remaining_payload_slice = remaining_payload.begin_parse();
        ctx_root = remaining_payload_slice~load_uint(256);
        save_data();
        return ();
    } elseif (op == op::cancel_otp) {
        ;; cancel otp and remove from extension list
        send_raw_message(
            begin_cell()
                .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
                .store_slice(ctx_wallet_address)
                .store_coins(20000000)
                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(
                    remaining_payload
                )
                .end_cell(),
            0
        );
        ;; todo send remaining balance to the ctx_wallet_address and only keep a small amount
        save_data();
        return ();
    }
    return ();


}

;; Get methods

int seqno() method_id {
    load_data();
    return ctx_nonce;
}

int get_public_key() method_id {
    load_data();
    return ctx_public_key;
}

slice get_wallet_address() method_id {
    load_data();
    return ctx_wallet_address;
}

int get_mode() method_id {
    load_data();
    return ctx_mode;
}

int get_failed_attempts() method_id {
    load_data();
    return ctx_failed_attempts;
}

int get_expiration_time() method_id {
    load_data();
    return ctx_expiration_time;
}

int get_root() method_id {
    load_data();
    return ctx_root;
}

int get_time() method_id {
    return now();
}

