#include "imports/stdlib.fc";

int bls_pairing_check(slice x1, slice y1, slice x2, slice y2, slice x_3, slice y_3, slice x_4, slice y_4, int n) asm "BLS_PAIRING";
slice bls_g1_negate(slice x) asm "BLS_G1_NEG";
slice bls_g1_mul(slice x, int s) asm "BLS_G1_MUL";
slice bls_g1_add(slice x, slice y) asm "BLS_G1_ADD";


;; these ops need otp code verify
const op::refresh_otp = "op::refresh_otp"c;
const op::cancel_otp = "op::cancel_otp"c;
const op::send_msg = "op::send_msg"c;


;; these ops don't needs otp code verify
const op::activate_emergency = "op::activate_emergency"c; ;; done


;; only internal messages
const op::disable_emergency = "op::disable_emergency"c; ;; done
const op::change_public_key = "op::change_public_key"c; ;; done
const op::set_code = "op::set_code"c; ;; done


const mode::emeregency = 1; ;; in this mode the wallet private key is probably compromised and every message should be checked by OTP code in recv_internal
const mode::not_init = 2; ;; in this mode we need to send the wallet to turn off sign mode(during deploy tx)



;; storage variables
global int ctx_mode;
global int ctx_root;
global int ctx_nonce;
global int ctx_last_time;
global int ctx_expiration_time;
global int ctx_failed_attempts;
global int ctx_public_key;
global slice ctx_wallet_address;

;; load_data populates storage variables using stored data
() load_data() impure {
    var ds = get_data().begin_parse();
    ctx_mode = ds~load_uint(2);
    ctx_root = ds~load_uint(256);
    ctx_nonce = ds~load_uint(32);
    ctx_last_time = ds~load_uint(64);
    ctx_failed_attempts = ds~load_uint(4);
    ctx_expiration_time = ds~load_uint(32);
    ctx_public_key = ds~load_uint(256);
    ctx_wallet_address = ds~load_msg_addr();

    ds.end_parse();
}

;; save_data stores storage variables as a cell into persistent storage
() save_data() impure {
    set_data(
        begin_cell()
            .store_uint(ctx_mode, 2) ;;
            .store_uint(ctx_root, 256)
            .store_uint(ctx_nonce, 32)
            .store_uint(ctx_last_time, 64)
            .store_uint(ctx_failed_attempts, 4)
            .store_uint(ctx_expiration_time, 32)
            .store_uint(ctx_public_key, 256)
            .store_slice(ctx_wallet_address)
            .end_cell()
    );
}

(int) check_otp_proof(int time, int root, slice otp_proof) impure inline {
    try {
        slice IC0 = "a8fce2adf12d72e669ea3907620ed993d02dbb554cb9d07a0501f8b520c14c77ba999dc95d6d4c48aee32936cf7b1fbc"s;
        slice IC1 = "a6e8bfef42a1dcad425c57047b55bb02bfbf3fa61f783b0b967dbd106978d401294b42320f6b3ec19d231404fffc3181"s;
        slice IC2 = "a0c004fdbb9fc6776cf3ea1fbaefe20ba3d0e6181d7e3703dc1deb53b8ff2e9c87510e13a1836610ede825086c5691f4"s;

        slice gamma2 = "93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"s;
        slice delta2 = "a69cd66c681bffb2b6f124caba2d5d2fa5bddc3ad149716d2b50b63c2d356fb471b9671ff29042a15e4382068b9d5325111cb17047c092f3132fd9e7d27ce7521a8d92d1a107801794b7e499f46d61c62c690de73f5e6e54c8c46f722c11dc2e"s;
        slice alf1 = "86eb9de1fae7b540e09c26303cee8b99784835d37bf46f3fb1db25b7b063d9ab9aa866e79f7cc4eb209224c8465b9bde"s;
        slice beta2 = "9091cd3cdc8abaa367a61d5e094dc91ceec4a831f9c995e0b6d38cff4a9cf897a6bb7cc6d1fbb54068bbd8bb479e56d5010417ac1b215ac661897a156c587791a9cc20dffd3d60009696a749136c6b874f8f7a6c2e951843ef410ee953d0354c"s;

        cell A_cell = otp_proof~load_ref();
        cell B_cell = otp_proof~load_ref();
        cell C_cell = otp_proof~load_ref();
        slice A = A_cell.begin_parse();
        slice B = B_cell.begin_parse();
        slice C = C_cell.begin_parse();
        slice vk_x = IC0;

        vk_x = bls_g1_add(vk_x, bls_g1_mul(IC1, time));
        vk_x = bls_g1_add(vk_x, bls_g1_mul(IC2, root));

        slice neg_a = bls_g1_negate(A);

        return bls_pairing_check(neg_a,
            B,
            alf1,
            beta2,
            vk_x,
            gamma2,
            C,
            delta2,
            4);
    } catch (_, _){
        return 0;
    }

}

(int) valid_time(int time) impure inline {
    ;; return
    if (time <= ctx_last_time) {
        return false;
    }
    return (time < (now() * 1000 + 60000)) & (time > (now() * 1000 - 60000));
}
;; recv_internal is the main function of the contract and is called when it receives a message from other contracts
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }


    load_data();

    if (ctx_mode == mode::not_init) {
        send_raw_message(
            begin_cell()
                .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
                .store_slice(ctx_wallet_address)
                .store_coins(20000000)
                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(
                    in_msg_body~load_ref()
                )
                .end_cell(),
            0
        );
        ctx_mode = 0;
        save_data();
        return ();
    }
    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case


    ;; todo should add transfer notifcation here to extend the expiration time:)
    var signature = in_msg_body~load_bits(512);
    slice signed_payload = in_msg_body;
    var op_signed = in_msg_body~load_uint(32);
    throw_unless(38, op_signed == op);
    throw_unless(35, check_signature(slice_hash(signed_payload), signature, ctx_public_key));

    int time = in_msg_body~load_uint(64); ;; in milliseconds

    throw_unless(33, valid_time(time));
    int check_otp = check_otp_proof(time, ctx_root, in_msg_body~load_ref().begin_parse());
    throw_unless(34, check_otp);
    ctx_failed_attempts = 0;
    ctx_last_time = time;
    if (op == op::disable_emergency) {
        ctx_mode = 0;
        save_data();
        return ();
    }

    if (op == op::change_public_key) {
        ctx_public_key = in_msg_body~load_uint(256);
        save_data();
        return ();
    }

    if (op == op::refresh_otp) {
        ctx_root = in_msg_body~load_uint(256);
        save_data();
        return ();
    }


    if (op == op::cancel_otp) {
        ;; cancel otp and remove from extension list
        send_raw_message(
            begin_cell()
                .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
                .store_slice(ctx_wallet_address)
                .store_coins(20000000)
                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(
                    in_msg_body~load_ref()
                )
                .end_cell(),
            0
        );
        ;; todo send remaining balance to the ctx_wallet_address and only keep a small amount
        save_data();
        return ();
    }

    if (op == op::send_msg) {
        var coins = in_msg_body~load_coins();
        send_raw_message(
            begin_cell()
                .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
                .store_slice(ctx_wallet_address)
                .store_coins(coins)
                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(
                    in_msg_body~load_ref()
                )
                .end_cell(),
            0
        );
        save_data();
        return ();
    }
    if (op == op::set_code) {
        cell new_code = in_msg_body~load_ref();

        set_c3(new_code.begin_parse().bless());
        load_data();
        set_code(new_code);

        save_data();
        return ();
    }
    ;; todo should add other ops also


    throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
}

;; get methods are a means to conveniently read contract data using, for example, HTTP APIs
;; they are marked with method_id
;; note that unlike in many other smart contract VMs, get methods cannot be called by other contracts


() recv_external(slice in_msg) impure {
    var signature = in_msg~load_bits(512);
    var cs = in_msg;
    var (op, valid_until, msg_seqno) = (cs~load_uint(32), cs~load_uint(32), cs~load_uint(32));
    throw_if(32, valid_until <= now());

    load_data();
    throw_unless(35, check_signature(slice_hash(in_msg), signature, ctx_public_key));
    throw_unless(33, msg_seqno == ctx_nonce);
    if (mode::emeregency == ctx_mode) {
        throw(36);
    }

    if ((op == op::activate_emergency) | (ctx_failed_attempts >= 3)) {
        accept_message();
        ctx_mode = mode::emeregency;
        ctx_nonce += 1;
        save_data();
        return ();
    }

    int time = cs~load_uint(64); ;; in milliseconds
    throw_unless(41, valid_time(time));
    slice proof_data = cs~load_ref().begin_parse();
    accept_message();


    int check_otp = check_otp_proof(time, ctx_root, proof_data);

    if (check_otp == 0) {
        ;; otp proof is invalid
        ctx_failed_attempts += 1;
        ctx_nonce += 1;
        save_data();
        return ();
    }
    ctx_last_time = time;
    ctx_failed_attempts = 0;
    ctx_nonce += 1;

    if (op == op::send_msg) {
        var coins = cs~load_coins();
        send_raw_message(
            begin_cell()
                .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
                .store_slice(ctx_wallet_address)
                .store_coins(coins)
                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(
                    cs~load_ref()
                )
                .end_cell(),
            0
        );
        save_data();
        return ();
    } elseif (op == op::refresh_otp) {
        ctx_root = cs~load_uint(256);
        save_data();
        return ();
    } elseif (op == op::cancel_otp) {
        ;; cancel otp and remove from extension list
        send_raw_message(
            begin_cell()
                .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
                .store_slice(ctx_wallet_address)
                .store_coins(20000000)
                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(
                    cs~load_ref()
                )
                .end_cell(),
            0
        );
        ;; todo send remaining balance to the ctx_wallet_address and only keep a small amount
        save_data();
        return ();
    }
    return ();


}

;; Get methods

int seqno() method_id {
    load_data();
    return ctx_nonce;
}

int get_public_key() method_id {
    load_data();
    return ctx_public_key;
}

slice get_wallet_address() method_id {
    load_data();
    return ctx_wallet_address;
}

int get_mode() method_id {
    load_data();
    return ctx_mode;
}

int get_failed_attempts() method_id {
    load_data();
    return ctx_failed_attempts;
}

int get_expiration_time() method_id {
    load_data();
    return ctx_expiration_time;
}

int get_root() method_id {
    load_data();
    return ctx_root;
}

int get_time() method_id {
    return now();
}

